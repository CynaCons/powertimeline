"""
Agent Logger Module

Provides deterministic logging for agent spawns and results.
Updates IAC.md (Inter-Agent Communication) and CONTEXT.md automatically.

This module ensures all agent interactions are logged consistently,
without relying on agents to update documentation themselves.

v0.5.14.1: Added file locking for concurrent agent safety
"""

import uuid
import threading
import json
from datetime import datetime
from pathlib import Path
from typing import Optional, Any
from dataclasses import dataclass
from contextlib import contextmanager

# Global lock for file operations (thread-safe within process)
_file_lock = threading.Lock()


def get_agents_dir() -> Path:
    """Get the agents directory path."""
    return Path(__file__).parent


def generate_spawn_id() -> str:
    """Generate a short unique ID for a spawn."""
    return uuid.uuid4().hex[:8]


def now_iso() -> str:
    """Get current timestamp in ISO format (UTC)."""
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")


def now_time() -> str:
    """Get current time only (UTC)."""
    return datetime.utcnow().strftime("%H:%M:%S")


def now_date() -> str:
    """Get current date only (UTC)."""
    return datetime.utcnow().strftime("%Y-%m-%d")


def sanitize_for_table(text: str, max_len: int = 60) -> str:
    """Sanitize text for markdown table display (remove newlines, truncate)."""
    if not text:
        return ""
    # Replace newlines with spaces, collapse multiple spaces
    clean = ' '.join(text.split())
    if len(clean) > max_len:
        return clean[:max_len-3] + "..."
    return clean


@dataclass
class SpawnRecord:
    """Record of an agent spawn for logging."""
    spawn_id: str
    agent: str
    model: str
    task_summary: str
    prompt: str
    tools: list[str]
    started_at: str
    completed_at: Optional[str] = None
    duration_seconds: Optional[float] = None
    success: Optional[bool] = None
    cost_usd: Optional[float] = None
    result_summary: Optional[str] = None
    error: Optional[str] = None


class AgentLogger:
    """
    Logger for agent spawns and results.

    Manages IAC.md and CONTEXT.md updates.
    """

    def __init__(self):
        self.agents_dir = get_agents_dir()
        self.iac_path = self.agents_dir / "IAC.md"
        self.context_path = self.agents_dir / "CONTEXT.md"
        self.active_spawns: dict[str, SpawnRecord] = {}
        self.max_recent_runs = 10

    def _ensure_iac_exists(self):
        """Ensure IAC.md exists with proper header."""
        if not self.iac_path.exists():
            self.iac_path.write_text(
                "# Inter-Agent Communication Log\n\n"
                "This file is auto-generated by the agent orchestration system.\n"
                "Do not edit manually.\n\n"
                "---\n\n",
                encoding='utf-8'
            )

    def _read_iac(self) -> str:
        """Read IAC.md content."""
        self._ensure_iac_exists()
        return self.iac_path.read_text(encoding='utf-8')

    def _append_iac(self, content: str):
        """Append content to IAC.md (thread-safe)."""
        with _file_lock:
            self._ensure_iac_exists()
            current = self._read_iac()

            # Check if we need a new date header
            today = now_date()
            if f"## {today}" not in current:
                content = f"## {today}\n\n{content}"

            with open(self.iac_path, 'a', encoding='utf-8') as f:
                f.write(content)

    def _update_iac_entry(
        self,
        spawn_id: str,
        success: bool,
        result_text: str,
        duration_seconds: float,
        cost_usd: float,
        error: Optional[str] = None,
    ):
        """Update an existing IAC entry with completion data (thread-safe)."""
        with _file_lock:
            content = self._read_iac()

            # Build status string for checkbox line
            if success:
                new_checkbox = f"- [x] ‚úÖ **Done** ({duration_seconds:.1f}s, ${cost_usd:.4f})"
            else:
                new_checkbox = f"- [x] ‚ùå **Failed**: {error or 'Unknown'} ({duration_seconds:.1f}s)"

            # Find and update the running checkbox line for this spawn
            import re
            # Match: - [ ] ‚è≥ **Running** | `#spawn_id` | rest of line
            old_pattern = rf"- \[ \] ‚è≥ \*\*Running\*\* \| `#{spawn_id}` \| ([^\n]+)"
            new_line = f"{new_checkbox} | `#{spawn_id}` | \\1"
            content = re.sub(old_pattern, new_line, content)

            # Replace result placeholder with actual result
            result_placeholder = f"<!-- RESULT_{spawn_id} -->"
            # Truncate very long results for display but keep essential info
            display_result = result_text
            if len(result_text) > 50000:
                display_result = result_text[:25000] + "\n\n... [truncated] ...\n\n" + result_text[-25000:]

            # Use 4 backticks as fence if result contains triple backticks
            fence = "````" if "```" in display_result else "```"

            result_block = f"""<details>
<summary>üì§ Output ({len(result_text)} chars)</summary>

{fence}
{display_result}
{fence}

</details>

---"""
            content = content.replace(result_placeholder, result_block)

            # Write back
            self.iac_path.write_text(content, encoding='utf-8')

    def log_spawn_start(
        self,
        agent: str,
        model: str,
        prompt: str,
        tools: list[str],
        task_summary: Optional[str] = None,
    ) -> str:
        """
        Log the start of an agent spawn.

        Returns the spawn_id for tracking.
        """
        spawn_id = generate_spawn_id()
        started_at = now_iso()

        # Create task summary from first line of prompt if not provided
        if not task_summary:
            first_line = prompt.split('\n')[0][:80]
            task_summary = first_line + ('...' if len(prompt.split('\n')[0]) > 80 else '')

        record = SpawnRecord(
            spawn_id=spawn_id,
            agent=agent,
            model=model,
            task_summary=task_summary,
            prompt=prompt,
            tools=tools,
            started_at=started_at,
        )
        self.active_spawns[spawn_id] = record

        # Write to IAC.md - unified entry format (will be updated on completion)
        tools_str = ', '.join(tools) if tools else 'None'

        # Escape backticks in prompt to prevent breaking markdown code fences
        # Use 4 backticks as fence if prompt contains triple backticks
        fence = "````" if "```" in prompt else "```"

        iac_entry = f"""
### ü§ñ {task_summary}
- [ ] ‚è≥ **Running** | `#{spawn_id}` | {agent} ({model}) | {now_time()} | Tools: {tools_str}

<details>
<summary>üì• Input ({len(prompt)} chars)</summary>

{fence}
{prompt}
{fence}

</details>

<!-- RESULT_{spawn_id} -->

"""
        self._append_iac(iac_entry)

        # Update CONTEXT.md with active spawn
        self._update_context()

        return spawn_id

    def log_spawn_complete(
        self,
        spawn_id: str,
        success: bool,
        result_text: str,
        duration_seconds: float,
        cost_usd: float = 0.0,
        error: Optional[str] = None,
    ):
        """Log the completion of an agent spawn."""
        record = self.active_spawns.get(spawn_id)
        if not record:
            # Spawn wasn't tracked, create minimal record
            record = SpawnRecord(
                spawn_id=spawn_id,
                agent="unknown",
                model="unknown",
                task_summary="Unknown task",
                prompt="",
                tools=[],
                started_at=now_iso(),
            )

        record.completed_at = now_iso()
        record.duration_seconds = duration_seconds
        record.success = success
        record.cost_usd = cost_usd
        record.error = error

        # Store full result (not truncated)
        record.result_summary = result_text

        # Update existing entry in IAC.md instead of appending
        self._update_iac_entry(spawn_id, success, result_text, duration_seconds, cost_usd, error)

        # Remove from active spawns
        if spawn_id in self.active_spawns:
            del self.active_spawns[spawn_id]

        # Update CONTEXT.md
        self._update_context(completed_record=record)

    def _update_context(self, completed_record: Optional[SpawnRecord] = None):
        """Update CONTEXT.md with current state."""
        # Recent runs are stored in-memory only (reset on server restart)
        # IAC.md is the authoritative log for history

        # Build active agents table
        active_table = "| ID | Agent | Task | Started |\n|-----|-------|------|--------|\n"
        if self.active_spawns:
            for sid, rec in self.active_spawns.items():
                task_clean = sanitize_for_table(rec.task_summary, 60)
                active_table += f"| {sid} | {rec.agent} | {task_clean} | {rec.started_at} |\n"
        else:
            active_table += "| - | - | No active agents | - |\n"

        # Write CONTEXT.md (thread-safe)
        with _file_lock:
            context_content = f"""# Agent Context

> Auto-generated by agents/logger.py. Do not edit manually.

**Last Updated:** {now_iso()} UTC

---

## Active Agents

{active_table}

---

## Notes

- This file shows currently running agents only
- See IAC.md for full interaction history
- See MCP_DESIGN.md for architecture documentation
"""
            self.context_path.write_text(context_content, encoding='utf-8')


# Global logger instance
_logger: Optional[AgentLogger] = None


def get_logger() -> AgentLogger:
    """Get or create the global logger instance."""
    global _logger
    if _logger is None:
        _logger = AgentLogger()
    return _logger


def log_spawn_start(
    agent: str,
    model: str,
    prompt: str,
    tools: list[str],
    task_summary: Optional[str] = None,
) -> str:
    """Log the start of an agent spawn. Returns spawn_id."""
    return get_logger().log_spawn_start(agent, model, prompt, tools, task_summary)


def log_spawn_complete(
    spawn_id: str,
    success: bool,
    result_text: str,
    duration_seconds: float,
    cost_usd: float = 0.0,
    error: Optional[str] = None,
):
    """Log the completion of an agent spawn."""
    get_logger().log_spawn_complete(
        spawn_id, success, result_text, duration_seconds, cost_usd, error
    )
